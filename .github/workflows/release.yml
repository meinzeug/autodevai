name: Release Pipeline

permissions:
  contents: write
  discussions: write
  packages: write
  issues: write
  actions: read

on:
  push:
    tags:
      - 'v*.*.*'
      - 'v*.*.*-*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.3)'
        required: true
        type: string
      release_type:
        description: 'Release type'
        required: true
        default: 'release'
        type: choice
        options:
          - 'release'
          - 'prerelease'
          - 'draft'
      force_build:
        description: 'Force rebuild even if artifacts exist'
        required: false
        default: false
        type: boolean

env:
  CARGO_TERM_COLOR: always
  NODE_VERSION: '22'
  RUST_VERSION: '1.75.0'
  TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
  TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}

jobs:
  # Prepare release metadata
  prepare:
    name: Prepare Release
    runs-on: ubuntu-22.04
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_number: ${{ steps.version.outputs.version_number }}
      tag: ${{ steps.version.outputs.tag }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      changelog: ${{ steps.changelog.outputs.changelog }}
      release_notes: ${{ steps.release_notes.outputs.notes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version information
        id: version
        env:
          # SECURITY FIX: Use environment variables to prevent script injection
          INPUT_VERSION: ${{ github.event.inputs.version }}
          INPUT_RELEASE_TYPE: ${{ github.event.inputs.release_type }}
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
        run: |
          # SECURITY FIX: Get values from environment variables instead of direct interpolation
          if [[ "${EVENT_NAME}" == "workflow_dispatch" ]]; then
            # Sanitize inputs by removing any shell metacharacters and limiting length
            RAW_VERSION="${INPUT_VERSION:-}"
            RAW_RELEASE_TYPE="${INPUT_RELEASE_TYPE:-release}"
            
            # Remove dangerous characters and limit length
            VERSION=$(printf '%.50s' "${RAW_VERSION}" | tr -cd '[:alnum:].-')
            RELEASE_TYPE=$(printf '%.20s' "${RAW_RELEASE_TYPE}" | tr -cd '[:alnum:]')
            
            # Validate version format with strict regex
            if [[ ! "${VERSION}" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
              echo "Error: Invalid version format: ${VERSION}"
              exit 1
            fi
            
            # Validate release type
            if [[ ! "${RELEASE_TYPE}" =~ ^(release|prerelease|draft)$ ]]; then
              echo "Error: Invalid release type: ${RELEASE_TYPE}"
              exit 1
            fi
          else
            VERSION="${REF_NAME}"
            if [[ "${VERSION}" == *"-"* ]]; then
              RELEASE_TYPE="prerelease"
            else
              RELEASE_TYPE="release"
            fi
          fi

          VERSION_NUM=${VERSION#v}
          IS_PRERELEASE=$([[ "$RELEASE_TYPE" == "prerelease" || "$VERSION" == *"-"* ]] && echo "true" || echo "false")

          # Use printf to safely output values
          printf 'version=%s\n' "${VERSION}" >> $GITHUB_OUTPUT
          printf 'version_number=%s\n' "${VERSION_NUM}" >> $GITHUB_OUTPUT
          printf 'tag=%s\n' "${VERSION}" >> $GITHUB_OUTPUT
          printf 'is_prerelease=%s\n' "${IS_PRERELEASE}" >> $GITHUB_OUTPUT

          printf 'Release version: %s\n' "${VERSION}"
          printf 'Version number: %s\n' "${VERSION_NUM}"
          printf 'Is prerelease: %s\n' "${IS_PRERELEASE}"

      - name: Generate changelog
        id: changelog
        run: |
          RELEASE_TAG="${{ steps.version.outputs.tag }}"
          # Get previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [[ -n "$PREV_TAG" ]]; then
            printf 'Generating changelog from %s to %s\n' "${PREV_TAG}" "${RELEASE_TAG}"
            # Use git log with safe format specifiers
            git log --pretty=format:"- %s (%h)" --no-merges "${PREV_TAG}..${RELEASE_TAG}" | head -20 > CHANGELOG_BRIEF.md
            git log --pretty=format:"- %s (%h) by %an" --no-merges "${PREV_TAG}..${RELEASE_TAG}" > CHANGELOG_FULL.md
          else
            echo "Generating changelog for initial release"
            git log --pretty=format:"- %s (%h)" --no-merges | head -20 > CHANGELOG_BRIEF.md
            git log --pretty=format:"- %s (%h) by %an" --no-merges > CHANGELOG_FULL.md
          fi

          # Save to output using heredoc to prevent injection
          {
            echo "changelog<<EOF"
            cat CHANGELOG_BRIEF.md
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: release_notes
        run: |
          RELEASE_VERSION="${{ steps.version.outputs.version }}"
          RELEASE_TAG="${{ steps.version.outputs.tag }}"
          GITHUB_REPOSITORY="${{ github.repository }}"
          
          cat > RELEASE_NOTES.md << 'EOF'
# AutoDev-AI Neural Bridge Platform %RELEASE_VERSION%

## üöÄ What's New

%CHANGELOG%

## üì¶ Installation

### Desktop Applications
**Windows:**
- `AutoDev-AI_%RELEASE_VERSION%_x64-setup.exe` - Windows 64-bit installer
- `AutoDev-AI_%RELEASE_VERSION%_arm64-setup.exe` - Windows ARM64 installer

**macOS:**
- `AutoDev-AI_%RELEASE_VERSION%_universal.dmg` - Universal binary (Intel + Apple Silicon)
- `AutoDev-AI_%RELEASE_VERSION%_x64.dmg` - Intel Macs only
- `AutoDev-AI_%RELEASE_VERSION%_aarch64.dmg` - Apple Silicon only

**Linux:**
- `AutoDev-AI_%RELEASE_VERSION%_amd64.AppImage` - x64 AppImage
- `AutoDev-AI_%RELEASE_VERSION%_arm64.AppImage` - ARM64 AppImage
- `autodev-ai_%RELEASE_VERSION%_amd64.deb` - Debian/Ubuntu package

### Docker Images
```bash
# Pull the latest image
docker pull ghcr.io/%GITHUB_REPOSITORY%:%RELEASE_VERSION%

# Run with port mapping
docker run -d \
  --name autodev-ai \
  -p 50020:50020 \
  -p 50021:50021 \
  -p 50022:50022 \
  ghcr.io/%GITHUB_REPOSITORY%:%RELEASE_VERSION%
```

### Kubernetes Deployment
```bash
# Apply Kubernetes manifests
kubectl apply -f https://github.com/%GITHUB_REPOSITORY%/releases/download/%RELEASE_TAG%/k8s-deployment.yaml
```

## ‚öôÔ∏è Configuration

- **Port Range**: 50000-50100 (configurable)
- **Default Ports**:
  - GUI Service: 50020
  - API Service: 50021
  - Sandbox Service: 50022
- **Claude-Flow Integration**: Built-in multi-agent orchestration
- **Neural Bridge**: WebAssembly-accelerated neural processing

## üîß System Requirements

- **Node.js**: 22.0+ (for development)
- **Rust**: 1.70+ (for building from source)
- **Docker**: 20.10+ (for containerized deployment)
- **Memory**: 4GB+ RAM recommended
- **Storage**: 2GB+ free space

## üÜï Features in This Release

- Enhanced neural bridge performance
- Improved Docker container orchestration
- Updated Tauri desktop application framework
- Advanced security scanning and monitoring
- Streamlined CI/CD pipeline
- Multi-architecture support (x64, ARM64)

## üêõ Bug Fixes and Improvements

- Fixed memory leaks in long-running processes
- Improved error handling and logging
- Enhanced security configurations
- Updated dependencies to latest versions
- Performance optimizations across all components

## üìö Documentation

- [Installation Guide](https://github.com/%GITHUB_REPOSITORY%/blob/%RELEASE_TAG%/docs/installation.md)
- [Configuration Reference](https://github.com/%GITHUB_REPOSITORY%/blob/%RELEASE_TAG%/docs/configuration.md)
- [API Documentation](https://github.com/%GITHUB_REPOSITORY%/blob/%RELEASE_TAG%/docs/api.md)
- [Troubleshooting](https://github.com/%GITHUB_REPOSITORY%/blob/%RELEASE_TAG%/docs/troubleshooting.md)

## ü§ù Contributing

We welcome contributions! Please read our [Contributing Guide](CONTRIBUTING.md) for details.

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

**Full Changelog**: https://github.com/%GITHUB_REPOSITORY%/compare/${PREV_TAG}...%RELEASE_TAG%
EOF

          # Safely substitute variables using sed
          sed -i "s|%RELEASE_VERSION%|${RELEASE_VERSION}|g" RELEASE_NOTES.md
          sed -i "s|%RELEASE_TAG%|${RELEASE_TAG}|g" RELEASE_NOTES.md
          sed -i "s|%GITHUB_REPOSITORY%|${GITHUB_REPOSITORY}|g" RELEASE_NOTES.md
          
          # Insert changelog content safely
          if [[ -f CHANGELOG_BRIEF.md ]]; then
            # Use a temporary file to safely insert changelog
            awk '/^%CHANGELOG%$/ {system("cat CHANGELOG_BRIEF.md"); next} {print}' RELEASE_NOTES.md > RELEASE_NOTES.tmp
            mv RELEASE_NOTES.tmp RELEASE_NOTES.md
          else
            sed -i 's|%CHANGELOG%|No changelog available|g' RELEASE_NOTES.md
          fi

          # Save release notes to output using heredoc
          {
            echo "notes<<EOF"
            cat RELEASE_NOTES.md
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Update version in files
        run: |
          VERSION_NUM="${{ steps.version.outputs.version_number }}"
          
          # Update package.json
          npm version "${VERSION_NUM}" --no-git-tag-version --allow-same-version

          # Update Cargo.toml
          cd src-tauri
          sed -i "s/^version = .*/version = \"${VERSION_NUM}\"/" Cargo.toml
          cd ..

          # Update tauri.conf.json
          jq --arg version "${VERSION_NUM}" '.version = $version' src-tauri/tauri.conf.json > tmp.json && mv tmp.json src-tauri/tauri.conf.json

      - name: Commit version updates
        run: |
          RELEASE_VERSION="${{ steps.version.outputs.version }}"
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.json package-lock.json src-tauri/Cargo.toml src-tauri/tauri.conf.json
          git commit -m "chore: bump version to ${RELEASE_VERSION}" || exit 0

      - name: Upload release artifacts
        uses: actions/upload-artifact@65462800fd760344b1a7b4382951275a0abb4808 # v4.3.3
        with:
          name: release-metadata
          path: |
            CHANGELOG_*.md
            RELEASE_NOTES.md
          retention-days: 90

  # Build multi-platform Tauri applications
  build-tauri:
    name: Build Tauri (${{ matrix.platform.name }})
    runs-on: ${{ matrix.platform.os }}
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        platform:
          - name: linux-x64
            os: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            arch: x64
            cmd: |
              sudo apt-get update
              sudo apt-get install -y libwebkit2gtk-4.0-dev libappindicator3-dev librsvg2-dev patchelf libgtk-3-dev libayatana-appindicator3-dev

          - name: linux-arm64
            os: ubuntu-22.04
            target: aarch64-unknown-linux-gnu
            arch: arm64
            cmd: |
              sudo apt-get update
              sudo apt-get install -y libwebkit2gtk-4.0-dev libappindicator3-dev librsvg2-dev patchelf libgtk-3-dev libayatana-appindicator3-dev
              sudo apt-get install -y gcc-aarch64-linux-gnu
              echo "CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
              echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV

    steps:
      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@60edb5dd545a775178f52524783378180af0d1f8 # v4.0.2
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@21dc36fb71dd22e3317045c0c31a3f4249868b17 # stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          targets: ${{ matrix.platform.target }}

      - name: Install platform dependencies
        run: ${{ matrix.platform.cmd }}

      - name: Install frontend dependencies
        run: npm install --prefer-offline

      - name: Build frontend
        run: npm run build

      - name: Create Tauri application
        id: tauri
        uses: tauri-apps/tauri-action@0e6ec9bb7e2aab7c2de1c93b88d2b8c6ccb9d4c4 # v0.5.12
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ENABLE_CODE_SIGNING: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          tagName: ${{ needs.prepare.outputs.tag }}
          releaseName: 'AutoDev-AI Neural Bridge ${{ needs.prepare.outputs.version }}'
          releaseBody: ${{ needs.prepare.outputs.release_notes }}
          releaseDraft: ${{ github.event.inputs.release_type == 'draft' }}
          prerelease: ${{ needs.prepare.outputs.is_prerelease }}
          args: --target ${{ matrix.platform.target }} --verbose
          includeUpdaterJson: true

      - name: Generate checksums
        run: |
          PLATFORM_NAME="${{ matrix.platform.name }}"
          PLATFORM_TARGET="${{ matrix.platform.target }}"
          
          cd "src-tauri/target/${PLATFORM_TARGET}/release/bundle"
          find . -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" \) \
            -exec sha256sum {} \; > "checksums-${PLATFORM_NAME}.txt"

          # Display checksums
          printf '=== Checksums for %s ===\n' "${PLATFORM_NAME}"
          cat "checksums-${PLATFORM_NAME}.txt"

      - name: Upload platform artifacts
        uses: actions/upload-artifact@65462800fd760344b1a7b4382951275a0abb4808 # v4.3.3
        with:
          name: tauri-${{ matrix.platform.name }}
          path: |
            src-tauri/target/${{ matrix.platform.target }}/release/bundle
            src-tauri/target/${{ matrix.platform.target }}/release/*.exe
          retention-days: 90

  # Build and publish Docker images
  build-docker:
    name: Build Docker Images
    runs-on: ubuntu-22.04
    needs: prepare
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        service: [gui, api, sandbox, all-in-one]
        platform: [linux/amd64, linux/arm64]
    steps:
      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Set up QEMU
        uses: docker/setup-qemu-action@68827325e0b33c7199eb31dd4e31fbe9023e06e3 # v3.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@d70bba72b1f3fd22344832f00baa16ece964efeb # v3.3.0

      - name: Log in to Container Registry
        uses: docker/login-action@e92390c5fb421da1463c202d546fed0ec5c39f20 # v3.1.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@8e5442c4ef9f78752691e2d8f8d19755c6f78e81 # v5.5.1
        with:
          images: ghcr.io/${{ github.repository }}/autodev-ai-${{ matrix.service }}
          tags: |
            type=raw,value=${{ needs.prepare.outputs.version }}
            type=raw,value=latest,enable=${{ needs.prepare.outputs.is_prerelease == 'false' }}
            type=raw,value=beta,enable=${{ needs.prepare.outputs.is_prerelease == 'true' }}

      - name: Build and push Docker image
        uses: docker/build-push-action@2cdde995de11925a030ce8070c3d77a52ffcf1c0 # v5.3.0
        with:
          context: .
          file: ./docker/Dockerfile.${{ matrix.service }}
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.prepare.outputs.version_number }}
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}

  # Create Kubernetes deployment manifests
  build-k8s:
    name: Build Kubernetes Manifests
    runs-on: ubuntu-22.04
    needs: [prepare, build-docker]
    steps:
      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Generate Kubernetes manifests
        run: |
          VERSION_NUMBER="${{ needs.prepare.outputs.version_number }}"
          GITHUB_REPOSITORY="${{ github.repository }}"
          RELEASE_VERSION="${{ needs.prepare.outputs.version }}"
          
          mkdir -p k8s-release

          # Create namespace
          cat > k8s-release/namespace.yaml << EOF
apiVersion: v1
kind: Namespace
metadata:
  name: autodev-ai
  labels:
    app.kubernetes.io/name: autodev-ai
    app.kubernetes.io/version: "${VERSION_NUMBER}"
EOF

          # Create deployment for each service
          for service in gui api sandbox; do
            port=$((50020 + $(echo "gui api sandbox" | tr ' ' '\n' | grep -n $service | cut -d: -f1) - 1))
            
            cat > k8s-release/${service}-deployment.yaml << EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: autodev-ai-${service}
  namespace: autodev-ai
  labels:
    app.kubernetes.io/name: autodev-ai
    app.kubernetes.io/component: ${service}
    app.kubernetes.io/version: "${VERSION_NUMBER}"
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: autodev-ai
      app.kubernetes.io/component: ${service}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: autodev-ai
        app.kubernetes.io/component: ${service}
    spec:
      containers:
      - name: ${service}
        image: ghcr.io/${GITHUB_REPOSITORY}/autodev-ai-${service}:${RELEASE_VERSION}
        ports:
        - containerPort: ${port}
          name: http
        env:
        - name: PORT
          value: "${port}"
        - name: NODE_ENV
          value: "production"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: autodev-ai-${service}
  namespace: autodev-ai
  labels:
    app.kubernetes.io/name: autodev-ai
    app.kubernetes.io/component: ${service}
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: http
    protocol: TCP
    name: http
  selector:
    app.kubernetes.io/name: autodev-ai
    app.kubernetes.io/component: ${service}
EOF
          done

          # Create combined deployment file
          cat k8s-release/*.yaml > k8s-release/autodev-ai-${RELEASE_VERSION}.yaml

      - name: Upload Kubernetes manifests
        uses: actions/upload-artifact@65462800fd760344b1a7b4382951275a0abb4808 # v4.3.3
        with:
          name: kubernetes-manifests
          path: k8s-release/
          retention-days: 90

  # Create GitHub release
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-22.04
    needs:
      [prepare, build-tauri, build-docker, build-k8s]
    if: always() && (needs.build-tauri.result == 'success' || needs.build-docker.result == 'success')
    permissions:
      contents: write
      discussions: write
    outputs:
      release_id: ${{ steps.release.outputs.id }}
      upload_url: ${{ steps.release.outputs.upload_url }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@65a9edc5881444af0b9093a5e628f2fe47ea3b2e # v4.1.7
        with:
          path: ./artifacts

      - name: Create release
        id: release
        uses: softprops/action-gh-release@69320dbe05506a9a39fc8ae11030b214ec2d1f87 # v2.0.5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.prepare.outputs.tag }}
          name: 'AutoDev-AI Neural Bridge ${{ needs.prepare.outputs.version }}'
          body: ${{ needs.prepare.outputs.release_notes }}
          draft: ${{ github.event.inputs.release_type == 'draft' }}
          prerelease: ${{ needs.prepare.outputs.is_prerelease }}

      - name: Upload release assets
        run: |
          GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          UPLOAD_URL="${{ steps.release.outputs.upload_url }}"
          RELEASE_VERSION="${{ needs.prepare.outputs.version }}"
          
          # Upload Tauri binaries
          find artifacts -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" \) | while read -r file; do
            filename=$(basename "$file")
            printf 'Uploading: %s\n' "${filename}"
            
            # SECURITY: Use curl with proper error handling and safe URL construction
            upload_url_clean="${UPLOAD_URL%\{*}"
            # Validate filename before upload
            if [[ "${filename}" =~ ^[a-zA-Z0-9._-]+$ ]]; then
              curl -L \
                -X POST \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                -H "Content-Type: application/octet-stream" \
                "${upload_url_clean}?name=${filename}" \
                --data-binary "@${file}" || printf 'Failed to upload %s\n' "${filename}"
            else
              printf 'Skipping invalid filename: %s\n' "${filename}"
            fi
          done

          # Upload Kubernetes manifests
          k8s_manifest="artifacts/kubernetes-manifests/autodev-ai-${RELEASE_VERSION}.yaml"
          if [[ -f "${k8s_manifest}" ]]; then
            upload_url_clean="${UPLOAD_URL%\{*}"
            curl -L \
              -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -H "Content-Type: application/x-yaml" \
              "${upload_url_clean}?name=k8s-deployment.yaml" \
              --data-binary "@${k8s_manifest}"
          fi

  # Post-release tasks
  post-release:
    name: Post-Release Tasks
    runs-on: ubuntu-22.04
    needs: [prepare, create-release]
    if: always() && needs.create-release.result == 'success'
    steps:
      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Update documentation
        run: |
          RELEASE_VERSION="${{ needs.prepare.outputs.version }}"
          CHANGELOG_CONTENT="${{ needs.prepare.outputs.changelog }}"
          
          # Update README with latest version
          sed -i "s/Version: [^)]*/Version: ${RELEASE_VERSION}/g" README.md

          # Update CHANGELOG
          if [[ -f CHANGELOG.md ]]; then
            cp CHANGELOG.md CHANGELOG.md.bak
            {
              echo "# Changelog"
              echo ""
              echo "## [${RELEASE_VERSION}] - $(date +%Y-%m-%d)"
              echo ""
              echo "${CHANGELOG_CONTENT}"
              echo ""
              tail -n +2 CHANGELOG.md.bak
            } > CHANGELOG.md
            rm CHANGELOG.md.bak
          fi

      - name: Commit documentation updates
        run: |
          RELEASE_VERSION="${{ needs.prepare.outputs.version }}"
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md CHANGELOG.md
          git commit -m "docs: update documentation for release ${RELEASE_VERSION}" || exit 0
          git push origin HEAD:main || exit 0

      - name: Trigger website deployment
        if: success()
        run: |
          WEBHOOK_URL="${{ secrets.WEBSITE_WEBHOOK_URL }}"
          RELEASE_VERSION="${{ needs.prepare.outputs.version }}"
          RELEASE_TAG="${{ needs.prepare.outputs.tag }}"
          GITHUB_REPOSITORY="${{ github.repository }}"
          
          if [[ -n "${WEBHOOK_URL}" ]]; then
            curl -X POST "${WEBHOOK_URL}" \
              -H "Content-Type: application/json" \
              -d "{
                \"version\": \"${RELEASE_VERSION}\",
                \"release_url\": \"https://github.com/${GITHUB_REPOSITORY}/releases/tag/${RELEASE_TAG}\",
                \"docker_image\": \"ghcr.io/${GITHUB_REPOSITORY}:${RELEASE_VERSION}\"
              }" || echo "Website update webhook failed (non-critical)"
          fi

      - name: Announce release
        run: |
          RELEASE_VERSION="${{ needs.prepare.outputs.version }}"
          RELEASE_TAG="${{ needs.prepare.outputs.tag }}"
          GITHUB_REPOSITORY="${{ github.repository }}"
          
          printf 'üéâ AutoDev-AI Neural Bridge %s has been released!\n' "${RELEASE_VERSION}"
          printf 'üì¶ Download: https://github.com/%s/releases/tag/%s\n' "${GITHUB_REPOSITORY}" "${RELEASE_TAG}"
          printf 'üê≥ Docker: docker pull ghcr.io/%s:%s\n' "${GITHUB_REPOSITORY}" "${RELEASE_VERSION}"
          printf '‚ò∏Ô∏è  Kubernetes: kubectl apply -f https://github.com/%s/releases/download/%s/k8s-deployment.yaml\n' "${GITHUB_REPOSITORY}" "${RELEASE_TAG}"

  # Rollback mechanism
  rollback:
    name: Release Rollback
    runs-on: ubuntu-22.04
    needs: [prepare, create-release]
    if: failure() && needs.prepare.outputs.version != ''
    steps:
      - name: Delete failed release
        env:
          # SECURITY FIX: Use environment variables to prevent script injection
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          RELEASE_TAG: ${{ needs.prepare.outputs.tag }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          RELEASE_VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          # SECURITY FIX: Get values from environment variables instead of direct interpolation
          
          echo "Release creation failed, cleaning up..."

          # Delete the release if it was created
          curl -L \
            -X DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${RELEASE_TAG}" \
            || echo "Release may not have been created"

          # Delete the tag if it was created via workflow_dispatch
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            curl -L \
              -X DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/git/refs/tags/${RELEASE_TAG}" \
              || echo "Tag deletion failed or tag doesn't exist"
          fi

          printf '‚ùå Release %s rollback completed\n' "${RELEASE_VERSION}"